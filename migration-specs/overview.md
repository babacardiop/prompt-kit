ğŸš€ Prompt Kit â€” Prompt-Driven Software Generation Framework
â€œFrom human specifications to verifiable, versioned, and traceable AI-generated code.â€

ğŸ§© 1ï¸âƒ£ï¸âƒ£ The Problem
AI coding assistants (Copilot, Cursor, Claude Codeâ€¦) boost productivity but lack structure, traceability, and governance.
Teams struggle with:
	â€¢ No clear mapping between specifications and generated code
	â€¢ Manual edits break generated logic with no re-verification mechanism
	â€¢ Inconsistent agent behavior and code style
	â€¢ No auditable record of what the AI produced or changed

ğŸ’¡ 2ï¸âƒ£ï¸âƒ£ The Solutioâ€” Prompt Kitit
Prompt Kit transforms prompting into a governed engineering process.
Inspired by GitHubâ€™s Spec-Kit, it re-imagines the idea for Prompt-Driven Generation (PDG).
Instead of directly generating code and tests, Prompt Kit produces structured prompt series â€” reusable, parameterized instructions that generate and verify software through governed AI execution.

ğŸ§± 3ï¸âƒ£ï¸âƒ£ Governance Pillars
Pillar	Definition	Benefit
ğŸ§¾ Logging	Every execution records inputs, outputs, agent used, and compile results.	Reproducibility
ğŸ”— Traceability	Each generated file includes headers with series/version/agent metadata.	Auditability
ğŸ—‚ï¸ Versioning	All AI-altered files and prompts are archived before updates.	Rollback safety
ğŸ§± Compilation Validation	Code is compiled post-generation to guarantee syntactic integrity.	Trust
Together they make Prompt Kit a CI/CD-grade AI development system.

ğŸ”„ 4ï¸âƒ£ï¸âƒ£ Lifecycle Overview
Creation Flow
/specify   â†’ define developer specs
/clarify   â†’ resolve ambiguities
/plan     â†’ produce task roadmap
/tasks    â†’ summarize actionable steps
/implement â†’ emit prompt series (generation + verification)

Operational Flow
/execute   â†’ run prompt series (full or partial)
/validate  â†’ re-run verifications anytime
/merge    â†’ extend existing series with new specs (version bump)
/migrate  â†’ re-generate code to new prompt version


ğŸ§  5ï¸âƒ£ï¸âƒ£ Prompt Series Structure
/prompts/
  /DTO-Synchronizer/
     /1.3.8/
        manifest.yaml
        generate-dto.prompt.md
        verify-dto.prompt.md
/logs/
/archive/
Each prompt file defines metadata:
---
id: generate-dto
series: DTO-Synchronizer
version: 1.3.8
type: generation
inputs:
  - entityName
  - targetPath
---

âš™ï¸ 6ï¸âƒ£ Key Commands
/implement â€” Create Prompt Series
Creates prompt templates and manifest from planned tasks.
Does not generate code â€” only prompt instructions.

/execute â€” Run Generation Pipeline
prompt-kit /execute <series> [version]
  [--from <start>] [--to <end>] 
  [--only a,b] [--skip x,y] 
  [--interactive|--non-interactive] [--agent claude]
Runs generation and verification prompts, asks for missing inputs, applies the four pillars, logs and compiles.

/validate â€” Re-Run Verification Prompts
prompt-kit /validate <series> [version] [--only a,b]
Checks that manual or external changes did not break generated contracts.

/merge â€” Evolve Existing Prompt Series
prompt-kit /merge <series> [version] @newSpecs.md
ğŸ§  The edit mode of /specify.
Flow
	1. Load existing series (manifest + prompts).
	2. Run /clarify â†’ /plan â†’ / tasks â†’ /implement in update mode.
	3. Perform housekeeping:
â€¢ Backup current prompts â†’ /archive
â€¢ Create new version folder
â€¢ Modify or extend prompt files
â€¢ Inject headers with Merged From and timestamp
	4. Optionally compile for validation.
	5. Log changes (added / modified / removed).

/migrate â€” Upgrade Generated Code
prompt-kit /migrate <series> --from <old> --to <new> [--scope path|phase|all]
Detects old-version trace headers, re-runs equivalent prompts from the new version, and regenerates safe scaffolds while preserving manual code.

ğŸ” 7ï¸âƒ£ï¸âƒ£ Command Relationships
Command	Affects	Pipeline	Scope
/specify	Prompts	Yes	Create new series
/merge	Prompts	Yes	Update existing series
/execute	Code	No	Generate artifacts
/validate	Code	No	Verify artifacts
/migrate	Code	No	Upgrade artifacts

ğŸ§© 8ï¸âƒ£ï¸âƒ£ Execution Granularity
Option	Meaning
--phase	Run single phase
--from / --to	Run range of phases
--only / --skip	Include or exclude phases
--interactive	Ask inputs
--non-interactive	Use cached defaults
--agent	Override default agent

ğŸ§± 9ï¸âƒ£ï¸âƒ£ Versioning and Traceability
Every artifact carries metadata:
// <auto-generated>
// Created by Prompt Kit v2.0.0 (Prompt-Driven Generation)
// Series: DTO-Synchronizer
// Version: 1.4.0
// Source Spec: @add-edit-dto.md
// Generated by: claude-3.5-sonnet
// </auto-generated>
All previous versions backed up to /archive/series/version/.
Logs written to /logs/YYYY-MM-DD/<series>_run.json.

ğŸ§± ğŸ”Ÿ Example Lifecycle
prompt-kit /specify @FullLayerSpec.md
prompt-kit /clarify
prompt-kit /plan
prompt-kit /tasks
prompt-kit /implement
prompt-kit /execute FullLayer 1.0.0
# Extend behavior
prompt-kit /merge FullLayer 1.0.0 @AddEditFlowSpec.md
prompt-kit /execute FullLayer 1.1.0
# Re-verify and upgrade
prompt-kit /validate FullLayer 1.1.0
prompt-kit /migrate FullLayer --from 1.0.0 --to 1.1.0

ğŸ§­ 11ï¸âƒ£ï¸âƒ£ Human-Safe Generation Architecture
Goal
AI-generated files must be regenerable without overwriting human extensions.
Prompt Kit enforces language-specific patterns to protect developer code.

C# Rules
Aspect	Rule
Classes	Always partial
Methods	Generated methods are virtual
Custom Files	*.Custom.cs added automatically
Migration	/migrate ignores *.Custom.cs
Manual Edits	Developers extend via partials/overrides only
Example
// BuildingDto.cs  (auto-generated)
public partial class BuildingDto
{
  public int Id { get; set; }
  public virtual void Validate() { /* generated */ }
}
// BuildingDto.Custom.cs  (user code)
public partial class BuildingDto
{
  public override void Validate()
  {
    base.Validate();
    if (string.IsNullOrEmpty(Name))
      throw new ValidationException("Name cannot be empty.");
  }
}
âœ… /migrate updates only BuildingDto.cs; BuildingDto.Custom.cs remains untouched.

React + TypeScript Rules
Aspect	Rule
Components	Split into *.generated.tsx and *.custom.tsx
Exports	index.tsx combines both
Hooks	Generated hooks are pure/stateless
Migration	Only *.generated.* files overwritten
Example
// BuildingList.generated.tsx
export const BuildingList = ({ buildings }: { buildings: Building[] }) => (
  <ul>{buildings.map(b => <li key={b.id}>{b.name}</li>)}</ul>
);
// BuildingList.custom.tsx
import { BuildingList } from './BuildingList.generated';
export const BuildingListExtended = (props) => (
  <div className="p-4 border">
    <h2>Enhanced Building List</h2>
    <BuildingList {...props} />
  </div>
);
âœ… During migration or merge, .generated.tsx files can change; .custom.tsx stay safe.

Housekeeping
	â€¢ Detect headers or filename patterns (*.Custom.cs, *.custom.tsx)
	â€¢ Never overwrite manual files during /migrate, /merge, or /execute
	â€¢ Compile both base + custom files after regeneration
	â€¢ Report any conflict but do not modify manual code

Manual Extension Schema in Prompts
manualExtension:
  pattern:
    csharp: "*.Custom.cs"
    react: "*.custom.tsx"
  strategy: preserve
  comment: "Add overrides here; Prompt Kit will ignore these files during migration."

âœ… 12ï¸âƒ£ Benefits Summary
Aspect	Advantage
Governance	Every AI action is logged and traceable
Evolution	/merge and /migrate keep prompts and code in sync
Safety	Manual code is never overwritten
Flexibility	Partial/virtual patterns for C# and custom split for React
Scalability	Granular phase execution and versioned series enable CI/CD integration

ğŸ”® 13ï¸âƒ£ï¸âƒ£ Strategic Summary
	Prompt Kit gives AI development the same rigor CI/CD gave manual development.
	Every prompt, generation, and change is traceable, verifiable, and safe for human collaboration.
It bridges AI creativity and software engineering discipline.

ğŸ§  14ï¸âƒ£ï¸âƒ£ Executive Pitch
	â€œPrompt Kit turns AI-generated code into an auditable engineering asset.
	We can generate, evolve, and migrate entire software layers without losing manual craftsmanship or traceability.
	Itâ€™s the future of governed AI software development.â€
